<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml">
    
<!-- Mirrored from blitz-wiki.appspot.com/Language reference?format=mobile by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 02 Feb 2012 22:34:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	  
      
        <link rel="stylesheet" type="text/css" href="gae-wiki-static/style_mobile.css"/>
      

	  <!--[if gte IE 6]>
      
        <link rel="stylesheet" type="text/css" href="gae-wiki-static/ie.css"/>
      
        <![endif]-->
		
      <link rel="shortcut icon" href="gae-wiki-static/favicon.ico" type="image/png" /> 
      <link rel="alternate" type="application/rss+xml" title="New Pages" href="w/index.rss" /> 
      
      <title>Language reference — Blitz Wiki</title>
      
      
      
      
    </head>
    <body>

    <div id="page">

<ul id="tabs">
<li><img style="vertical-align:middle" src="../commondatastorage.googleapis.com/monkeycoder.co.nz/blitz-wiki/monkeylogos/monkey16.png"></li>
<li><a class="int" href="Welcome4d8a.html?format=mobile">Home</a></li>
<li><a class="int" href="Tutorials4d8a.html?format=mobile">Tutorials</a></li>
<li><a class="int" href="Monk4d8a.html?format=mobile">Monk</a></li>
<li><a class="int" href="Trans4d8a.html?format=mobile">Trans</a></li>
<li><a class="int" href="Module%20reference4d8a.html?format=mobile">Modules</a></li>
<li><a class="int" href="Language%20reference4d8a.html?format=mobile">Language</a></li>
<li><a class="int" href="Installing_target_SDKs4d8a.html?format=mobile">Targets</a></li>
<li><a class="int" href="w/index4d8a.html?format=mobile">Index</a></li>
</ul>
      

<div class="wtabs extl" id="pb">
  
    
      <h1>Monkey language reference</h1>
<p>This manual describes the syntax and general concepts behind the core Monkey language.</p>
<h2>Contents</h2>
<p><a href="Language%20reference4d8a.html?format=mobile#about">About this reference</a><br />
<a href="Language%20reference4d8a.html?format=mobile#programs">Programs and declarations</a><br />
<a href="Language%20reference4d8a.html?format=mobile#strict">Strict mode</a><br />
<a href="Language%20reference4d8a.html?format=mobile#comments">Comments</a><br />
<a href="Language%20reference4d8a.html?format=mobile#identifiers">Identifiers</a><br />
<a href="Language%20reference4d8a.html?format=mobile#types">Types</a><br />
<a href="Language%20reference4d8a.html?format=mobile#variables">Variables</a><br />
<a href="Language%20reference4d8a.html?format=mobile#constants">Constants</a><br />
<a href="Language%20reference4d8a.html?format=mobile#expressions">Expressions</a><br />
<a href="Language%20reference4d8a.html?format=mobile#statements">Statements</a><br />
<a href="Language%20reference4d8a.html?format=mobile#functions">Function</a><br />
<a href="Language%20reference4d8a.html?format=mobile#methods">Methods</a><br />
<a href="Language%20reference4d8a.html?format=mobile#classes">Classes</a><br />
<a href="Language%20reference4d8a.html?format=mobile#generics">Generics</a><br />
<a href="Language%20reference4d8a.html?format=mobile#interfaces">Interfaces</a><br />
<a href="Language%20reference4d8a.html?format=mobile#modules">Modules</a><br />
<a href="Language%20reference4d8a.html?format=mobile#visibility">Public and private</a><br />
<a href="Language%20reference4d8a.html?format=mobile#extern">External declarations</a><br />
<a href="Language%20reference4d8a.html?format=mobile#memory">Memory management</a><br />
<a href="Language%20reference4d8a.html?format=mobile#preprocessor">Preprocessor</a></p>
<a name="about">

<h2>About this reference</h2>
</a>

<p>A monospaced font is used for program code examples, for example:</p>
<pre>
Function Main()
    Print "Hello World!"
End
</pre>

<p>Language syntax explanations are generally formatted as follows:</p>
<ul>
<li>
<p>Anything that appears in <code>bold</code> indicates literal text. For example: <code>Function</code> means the actual text 'Function'.</p>
</li>
<li>
<p>Anything that appears in <em>italics</em> indicates other syntax. For example: <em>Identifier</em> means any text that is a valid identifier.</p>
</li>
<li>
<p>Anything that appears in square brackets [ ] is optional. For example: [ <code>Step</code> ] means the literal text <code>Step</code> is optional.</p>
</li>
<li>
<p>The pipe character | is use for alternatives. For example: <code>To</code> | <code>Until</code> means you can use <code>To</code> or <code>Until</code> - but not both.</p>
</li>
<li>
<p>A three dots ellipsis … is used to indicate repetition.</p>
</li>
</ul>
<p>These rules are not strictly followed. Where it makes sense to do so, syntax may be shown in a simplified form with explanatory notes.</p>
<a name="programs">

<h2>Programs and declarations</h2>
</a>

<p>A Monkey program consists of one or more modules, each of which is a separate file, consisting of a series of declarations. </p>
<p>A declaration associates a 'meaning' with an identifier. For example, this declaration...</p>
<pre>
Global x:Int
</pre>

<p>...indicates that the identifier 'x' is a global variable of type 'Int' (an integer).</p>
<p>Monkey supports the following kinds of declarations:</p>
<ul>
<li>Modules</li>
<li>Constants</li>
<li>Local, Global and Field variables</li>
<li>Classes</li>
<li>Functions </li>
<li>Methods</li>
</ul>
<p>A module is itself a kind of declaration and is represented by a single source file. The name of the module is taken from the name of the source file. For example, if your file is named "particles.monkey" then the module will be called "particles".</p>
<p>Modules may 'import' other modules, which may in turn import other modules and so on.</p>
<p>Every Monkey program has a 'main module' that must contain a public function called Main that takes no parameters and returns an integer. For example:</p>
<pre>
Function Main()
    Print "That's all folks!"
End
</pre>

<p>This is the entry point of the program and is where program execution begins. </p>
<p>If you are using the mojo framework of modules, you must create a new class (which extends the base mojo.app class) and create a new instance of it in the Main function.&nbsp; See the mojo.app Module Reference for more information.&nbsp; An example of this is:</p>
<pre>
Import mojo.app
Import mojo.graphics

Class MyApp Extends App
    Method OnRender()
        DrawText "Hello World!",0,0
    End
End

Function Main()
        New MyApp
End
</pre>

<a name="strict">

<h2>Strict mode</h2>
</a>

<p>By default, Monkey allows you to take certain shortcuts when programming.</p>
<p>However, Monkey also offers a special Strict mode for programmers who prefer a stricter language definition.</p>
<p>The differences between strict and non-strict mode are:</p>
<ul>
<li>
<p>In non-strict mode, variable type, function return type and function parameter types can be optionally omitted. In this case they will default to Int. In strict mode, you must always specify the type of all variables, functions return values and function parameters.</p>
</li>
<li>
<p>In non-strict mode, Return statements can be omitted at the end of a function. In this case, a Return statement will be automatically generated that will return an appropriate default value for the function type. That is, False for bool, 0 for int and float, "" for string, [] for arrays and Null for objects. In strict mode, a function that does not return Void must end with a Return statement.</p>
</li>
<li>
<p>In non-strict mode, the brackets around function call parameters are optional if the function is being used as a statement, or if the function can be called with no parameters. In strict mode, all function call parameters must be enclosed in brackets.</p>
</li>
</ul>
<p>To use strict mode, a Strict directive must be placed at the very top of your module. For example:</p>
<pre>
Strict

Function Main:Int()                     'in Strict mode, the :Int type definition is compulsory
   Print( "Strict mode is...strict!" )  'in Strict mode, all function calls require brackets.
   Return 0                             'in strict mode, we MUST return a value.
End
</pre>

<p>The examples in this document will be presented in non-strict form.</p>
<a name="comments">

<h2>Comments</h2>
</a>

<p>You can add line comments to your programs using the ' (apostrophe) character. Everything following the ' character until the end of the line will be ignored.</p>
<p>You can add block comments to your programs using #rem and #end. These must appear at the start of a new line, although they may optionally have whitespace characters in front. Everything between #rem and #end will be ignored. Block comments can also be nested.</p>
<p>Here is an example of using comments:</p>
<pre>
Print "Hello World"                 'This is a line comment!

#rem                                'start of a block comment
Print "The sound of silence!"       'inside a block comment
#end                                'end of a block comment
</pre>

<a name="identifiers">

<h2>Identifiers</h2>
</a>

<p>Identifiers must start with an alphabetic character, or a single underscore followed by an alphabetic character. The rest of the identifier may contain any combination of alphanumeric characters and/or underscores.</p>
<p>Identifiers are case sensitive (except for language keywords - see below). For example, player, Player, PLAYER and PLayER are all different identifiers. This allows you to reuse the same name for different purposes. For example, Actor may refer to a class while actor refers to an object of that class.</p>
<p>Here are some examples of valid Monkey identifiers:</p>
<pre>
score
player1
player_up
_internal
helloworld
HelloWorld
</pre>

<h3>Language keywords and reserved identifiers</h3>
<p>The following identifiers are language keywords and are reserved for use by the Monkey language:</p>
<pre>
Void Strict Public Private Property Bool Int Float String Array
Object Mod Continue Exit Import Extern New Self Super 
Eachin True False Not Extends Abstract Final Select Case Default
Const Local Global Field Method Function Class And Or Shl Shr
End If Then Else ElseIf EndIf While Wend Repeat Until Forever 
For To Step Next Return Module Interface Implements Inline
</pre>

<p><a class="int" href="keywords4d8a.html?format=mobile" title="keywords">Language keywords</a> are case insensitive - for example, you may use the keyword function, Function or indeed even fUNCTION (not recommended) to declare a function.</p>
<p>The keywords Module, Interface, Implements, Inline and Array are not currently used by the Monkey language but are reserved for future use.</p>
<h3>Monkey naming conventions</h3>
<p>The standard Monkey modules use a simple naming convention:</p>
<ul>
<li>
<p>All-caps case (eg: 'ALLCAPS' ): Constants.</p>
</li>
<li>
<p>Pascal case (eg: 'PascalCase' ): Globals, functions, class, methods, properties.</p>
</li>
<li>
<p>Camel case (eg: 'camelCase' ): Fields, locals and function parameters.</p>
</li>
</ul>
<p>You are of course free to use your own convention, but for the sake of consistency it is recommended that this convention be used for the public interface of any modules you create intended for use by the Monkey community.</p>
<a name="types">

<h2>Types</h2>
</a>

<p>Monkey is a statically typed language, which means that all variables, function parameters, function return values and expressions have an associated type that is known at compile time.</p>
<p>The following types are supported:</p>
<p>Boolean<br />
Integer<br />
Floating point<br />
String<br />
Array<br />
Object<br />
</p>
<h3>The Bool type</h3>
<p>Values of type Bool are boolean values used to express the result of conditional expressions, such as the comparison operators, and to represent a true/false 'state' in general.&nbsp; A boolean value can only be either True or False. </p>
<p>The syntax used for declaring values and variables of boolean type is <code>Bool</code>.&nbsp; For example:</p>
<pre>
Local gamePaused:Bool = False
</pre>

<p>Boolean values are usually generated by the use of the comparison operators, for example:</p>
<pre>
If livesLeft<>0
    doSomething()
End
</pre>

<p>However, in some circumstances Monkey will automatically convert a non-bool value to bool. This will occur when evaluating an expression for use with the If or While statements; the Until part of a Repeat loop; and when evaluating the arguments for the Not, Or and And operators. For example:</p>
<pre>
If livesLeft
    doSomething()
End
</pre>

<p>See the conversions section in the expressions chapter for more information.</p>
<h3>The Int type</h3>
<p>Values of type Int are signed integer values - that is, values with no fractional part. The range of integer values supported is target dependent, but is at least 32 bits. A 32 bit int can represent a range of values from: -2,147,483,648 to 2,147,483,647</p>
<p>The syntax used for declaring values and variables of integer type is <code>Int</code>. For example:</p>
<pre>
Local x:Int = 5
</pre>

<p>Integer literals are sequences of digits without a fractional part. Hexadecimal literals are also supported with the $ prefix. For example, the following are all valid integer literals:</p>
<pre>
0
1234
$3D0DEAD
$CAFEBABE
</pre>

<h3>The Float type</h3>
<p>Values of type Float are signed numeric values with both an integer and fractional part. The range of floating point values support is target dependent, but is at least 32 bits.</p>
<p>The syntax used for declaring values and variables of floating point type is <code>Float</code>.&nbsp; For example:</p>
<pre>
Local gravity:Float = 9.81
</pre>

<p>Floating point literals are sequences of digits that include a fractional part, for example:</p>
<pre>
.0
0.0
.5
0.5
1.0
1.5
1.00001
3.14159265
</pre>

<h3>The String type</h3>
<p>Values of type String are used to represent sequences of characters, such as text. The size of each character in a string value is target dependent, but is at least 8 bits.</p>
<p>The syntax used for declaring values and variables of string type is <code>String</code>. For example:</p>
<pre>
Local name:String = "John Smith"
</pre>

<p>Strings are immutable meaning that once they are created they cannot be modified. Operations that 'modify' a string will always return a new string.</p>
<p>String literals are sequences of characters enclosed in "" (quotation marks). String literals may also include escape sequences - special sequences of characters used to represent unprintable characters.</p>
<p>You can use the following escape sequences in string literals:</p>
<table class="c">
<tr><th>Escape sequence</th><th>Character code</th></tr>
<tr><td><code>~q</code></td><td> 34 (quotate mark ")</td></tr>
<tr><td><code>~n</code></td><td> 10 (newline)</td></tr>
<tr><td><code>~r</code></td><td> 13 (return)</td></tr>
<tr><td><code>~t</code></td><td> 9 (tab)</td></tr>
<tr><td><code>~z</code></td><td> 0 (null></td></tr>
<tr><td><code>~~</code></td><td> 126 (tilde ~)</td></tr>
</table>

<p>Here are some examples of string literals:</p>
<pre>
"Hello World"
"~qHello World~q"
"~tIndented~n"
</pre>

<p>Strings can also be indexed and sliced.</p>
<p>The syntax for indexing a string is: <em>StringExpression</em> <code>[</code> <em>IndexExpression</em> <code>]</code></p>
<p>Indexing a string returns the character code of the character at IndexExpression. Index 0 is the first character in the string.</p>
<p>IndexExpression must be greater than or equal to 0 and less than the length of StringExpression otherwise an error occurs.</p>
<p>Here are some examples of indexing a string:</p>
<pre>
Print "ABC"[0]        'prints 65 - the character code of 'A'
Print "ABC"[1]        'prints 66 - the character code of 'B'
Print "Hi~n"[2]        'prints 10 - the character code of '~n'
</pre>

<p>The syntax for slicing a string is: <em>StringExpression</em><code>[</code> <em>StartExpression</em><code>..</code><em>EndExpression</em> <code>]</code></p>
<p>Slicing a string returns a new string consisting of the characters within StringExpression starting at index StartExpression and ending at index EndExpression.</p>
<p>Both StartExpression and EndExpression are optional. If StartExpression is omitted, it defaults to 0. If EndExpression is omitted, it defaults to the length of the string.</p>
<p>StartExpression and EndExpression can also be negative, in which case they refer to offsets from the end of the string.</p>
<p>Here are some examples of slicing a string:</p>
<pre>
Print "Hello World"[4..7]     'prints "o W'
Print "Hello World"[..5]    'prints "Hello"
Print "Hello World"[5..]    'prints "World"
Print "Hello World"[..]        'prints "Hello World"
</pre>

<p>Strings also support a number of 'pseudo' methods and functions:</p>
<table class="c">
<tr><th>Method/Function</th><th>Description</th></tr>
<tr><td>Method Length() Property</td><td> Returns the number of characters in the string.</td></tr>
<tr><td>Method Compare( str:String )</td><td> Returns a value <0 if the current string is less than str, a value>0 if the current string is greater than str or 0 if this string is equal to str.</td></tr>
<tr><td>Method Find( subString:String )</td><td> Returns the index of the first occurance of subString within the current string.</td></tr>
<tr><td>Method Find( subString:String, startIndex )</td><td> Returns the index of the first occurance of subString within the current string, starting at index startIndex.</td></tr>
<tr><td>Method FindLast( subString:String )</td><td> Returns the index of the last occurance of subString within the current string.</td></tr>
<tr><td>Method FindLast( subString:String, startIndex )</td><td> Returns the index of the last occurance of subString within the current string, starting at index startIndex.</td></tr>
<tr><td>Method Contains( subString:String )</td><td> Returns true if the current string contains subString.</td></tr>
<tr><td>Method StartsWith( subString:String )</td><td> Returns true if the current string starts with subString.</td></tr>
<tr><td>Method EndsWith( subString:String )</td><td> Returns true if the current string ends with subString.</td></tr>
<tr><td>Method ToLower:String()</td><td> Returns the current string converted to lowercase.</td></tr>
<tr><td>Method ToUpper:String()</td><td> Returns the current string converted to uppercase.</td></tr>
<tr><td>Method Trim:String()</td><td> Returns the current string with all leading and trailing whitespace characters removed.</td></tr>
<tr><td>Method Split:String[]( separator:String )</td><td> Returns an array of strings that contains the substrings in the current string deliminated by separator.</td></tr>
<tr><td>Method Join:String( pieces:String[] )</td><td> Returns the elements of pieces concatened together with the current string inserted between each substring.</td></tr>
<tr><td>Function FromChar:String( char )</td><td> Returns a string of length 1 consisting of a single character code.</td></tr>
</table>

<p>For example:</p>
<pre>
Print "  Hello World  ~n".Trim()    'prints "Hello World"
Print "Hello World".ToUpper()        'prints "HELLO WORLD"
</pre>

<h3>The Array type</h3>
<p>An array is a linear sequence of values that can be addressed using an integer index.</p>
<p>Each array has an associated element type - that is, the type of the elements actually contained in the array. Due to the nature of Monkey, an array's element type is a purely static property. It is only known at compile time so arrays cannot be downcast at runtime.</p>
<p>The syntax used for declaring values and variables of array type is: <em>ElementType</em> <code>[]</code></p>
<p>For example:</p>
<pre>
Local box:Int[]            'an array of ints
Local ratio:Float[]        'an array of floats
Local thing:Int[][]        'an array of arrays of ints
</pre>

<p>An array literal is a (possibly empty) comma separated sequence of expressions enclosed with [ and ]. The expressions used in an array literal must be of the same type. For example:</p>
<pre>
Local box:Int[]=[]                'an empty array literal
Local scores:Int[]=[10,20,30]        'a comma separated sequence
Local text:String[]=["Hello","There","World"]        'a comma separated sequence
</pre>

<p>The syntax for indexing an array is: <em>ArrayExpression</em> <code>[</code> <em>IndexExpression</em> <code>]</code>.&nbsp; For example:</p>
<pre>
Local score:Int[]=[10,20,30]        'a comma separated sequence
Print score[1]                        'prints "20"
</pre>

<p>Indexing an array yields a 'pseudo variable' of the array's element type that can be both read from and written to.</p>
<p>IndexExpression must be an integer expression greater than or equal to 0 and less than the length of the array otherwise an error occurs.</p>
<p>Like strings, arrays can also be sliced. The syntax for slicing an array is: <em>ArrayExpression</em> <code>[</code> <em>StartExpression</em> <code>..</code> <em>EndExpression</em> <code>]</code>.</p>
<p>Slicing an array returns 'sub array' of ArrayExpression starting at index StartExpression and ending at index EndExpression.</p>
<p>Both StartExpression and EndExpression are optional. If StartExpression is omitted, it defaults to 0. If EndExpression is omitted, it defaults to the length of the array.</p>
<p>StartExpression and EndExpression can also be negative, in which case they refer to offsets from the end of the array.</p>
<p>Here is an example of slicing an array:</p>
<pre>
Local text:String[]=["Cruel","Hello","World","There"]    'a comma separated sequence

Local helloWorld:=text[1..3]                            'contains ["Hello","World"]
</pre>

<p>Arrays also support a number of pseudo methods:</p>
<table class="c">
<tr><th>Method</th><th>Description</th></tr>
<tr><td>Method Length() Property</td><td> The number of elements in the array.</td></tr>
<tr><td>Method Resize:Array( newLength )</td><td> Copies the first newLength elements of the current array into a new array of length newLength, and returns the new array.</td></tr>
</table>

<p>For example:</p>
<pre>
Local text:String[]=["Hello","There","World"]        'a comma separated sequence

Print text.Length                'prints '3'

text=text.Resize( 2 )

Print text.Length                'prints '2'
</pre>

<h3>The Object type</h3>
<p>An object is an instance of a class, and contains a set of constants, variables, methods and functions.</p>
<p>The syntax used for declaring values and variables of object type is: <em>ClassIdentifier</em></p>
<p>For example:</p>
<pre>
Local mine:MyClass = New MyClass
</pre>

<p>Please see the <a href="Language%20reference4d8a.html?format=mobile#classes">classes</a> section for more information on declaring classes and creating objects.</p>
<a name="variables">

<h2>Variables</h2>
</a>

<p>A variable is a storage location used to hold values that change while your program runs.</p>
<p>All variables have an identifier, a type, and an optional initializer - an expression used to set the variable to an initial value.</p>
<p>The type of a variable can either be declared literally, or can be deduced from the variable's initializer.</p>
<h3>Local variables</h3>
<p>Local variables are temporary variables that disappear when the local scope they are declared in is destroyed.</p>
<p>Local variables may be declared within any local scope.</p>
<p>Each of the following creates a local scope:</p>
<ul>
<li>
<p>The statements inside a function or method.</p>
</li>
<li>
<p>The statements inside an If, Else If or If block.</p>
</li>
<li>
<p>The statements inside a Case or Default block.</p>
</li>
<li>
<p>The statements inside a While, Repeat or For loop.</p>
</li>
</ul>
<p>The syntax for declaring a local variable is:</p>
<p><code>Local</code> <em>Identifier</em> <code>:</code> <em>Type</em> [ <code>=</code> <em>Expression</em> ]</p>
<p>Or...</p>
<p><code>Local</code> <em>Identifier</em> <code>:=</code> <em>Expression</em></p>
<p>For example:</p>
<pre>
Local age:Int=10
Local age:=10
</pre>

<h3>Global variables</h3>
<p>Global variables are variables that persist during the execution of your program.</p>
<p>Global variables may be declared at module scope, or within a class declaration.</p>
<p>The syntax for declaring a global variable is:</p>
<p><code>Global</code> <em>Identifier</em> <code>:</code> <em>Type</em> [ <code>=</code> <em>Expression</em> ]</p>
<p>Or...</p>
<p><code>Global</code> <em>Identifier</em> <code>:=</code> <em>Expression</em></p>
<p>For example:</p>
<pre>
Global isPlayerAlive:Bool = True
</pre>

<h3>Field variables</h3>
<p>Field variables are variables that persist as long as the object they belong to. </p>
<p>Field variables can only be declared within a class declaration.</p>
<p>The syntax for declaring a field variable is:</p>
<p><code>Field</code> <em>Identifier</em> <code>:</code> <em>Type</em> [ <code>=</code> Expression ]</p>
<p>Or...</p>
<p><code>Field</code> <em>Identifier</em> <code>:=</code> <em>Expression</em></p>
<a name="constants">

<h2>Constants</h2>
</a>

<p>A constant is a value that is evaluated at compile time, and that does not change throughout the execution of a program.</p>
<p>Constants may be declared at module scope, within class scope or within any local scope.</p>
<p>The syntax for declaring a constant is:</p>
<p><code>Const</code> <em>Identifier</em> <code>:</code> <em>Type</em> <code>=</code> <em>Expression</em></p>
<p>Or...</p>
<p><code>Const</code> <em>Identifier</em> <code>:=</code> <em>Expression</em></p>
<a name="expressions">

<h2>Expressions</h2>
</a>

<p>Expressions are the parts of a program that perform calculations, make logical comparisons and return values from methods or functions.</p>
<h3>Operators</h3>
<table class="c">
<tr><th>Operator Syntax</th><th>Description</th></tr>
<tr><td><code>New</code> <i>ClassType</i></td><td>Create a new Object</td></tr>

<tr><td><code>Null</code></td><td>The null object</td></tr>
<tr><td><code>True</code></td><td>Boolean true</td></tr>
<tr><td><code>False</code></td><td>Boolean false</td></tr>
<tr><td><code>Self</code></td><td>Self</td></tr>
<tr><td><code>Super</code></td><td>Super</td></tr>
<tr><td><i>Literal</i></td><td>Literal</td></tr>
<tr><td><i>Identifier</i></td><td>Identifier</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>.</code> <i>Identifier</i></td><td>Scope member access</td></tr>
<tr><td><code>(</code> <i>ExpressionSeq</i> <code>)</code></td><td>Invoke</td></tr>
<tr><td><code>[</code> <i>Expression</i> <code>]</code></td><td>Index</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>+</code></td><td>Unary plus</td></tr>
<tr><td><code>-</code></td><td>Unary minus</td></tr>
<tr><td><code>~</code></td><td>Bitwise complement</td></tr>
<tr><td><code>Not</code></td><td>Boolean inverse</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>*</code></td><td>Multiplication</td></tr>
<tr><td><code>/</code></td><td>Division</td></tr>
<tr><td><code>Mod</code></td><td>Modulus</td></tr>
<tr><td><code>Shl</code></td><td>Bitwise shift left</td></tr>
<tr><td><code>Shr</code></td><td>Bitwise shift left (signed)</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>+</code></td><td>Addition</td></tr>
<tr><td><code>-</code></td><td>Subtraction</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>&</code></td><td>Bitwise 'and'</td></tr>
<tr><td><code>~</code></td><td>Bitwise 'xor'</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>|</code></td><td>Bitwise 'or'</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>=</code></td><td>Equals</td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equals</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equals</td></tr>
<tr><td><code>&lt;&gt;</code></td><td>Not equals</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>And</code></td><td>Condititonal 'and'</td></tr>

<tr><td colspan=2><hr></td></tr>

<tr><td><code>Or</code></td><td>Conditional 'or'</td></tr>

</table>

<h3>Balancing argument types</h3>
<p>When performing binary arithmetic (*, /, Mod, +, -) or comparison operations (=, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;), operator arguments are 'balanced' according to the following rules:</p>
<ul>
<li>
<p>If either operand is not string, float or int, then error,</p>
</li>
<li>
<p>else if either operand is a string, then the balanced type is string,</p>
</li>
<li>
<p>else if either operand is a float, then the balanced type is float,</p>
</li>
<li>
<p>else the balanced type is int.</p>
</li>
</ul>
<p>In the case of arithmetic operations, arguments are first implicitly converted to the balanced type if necessary, and the result is also of the balanced type.</p>
<p>In the case of comparison operations, arguments are first implicitly converted to the balanced type if necessary, and the result is boolean.</p>
<p>The only valid arithmetic operation that can be performed on strings is addition, which performs string concatentation on the arguments.</p>
<h3>Conditional operators</h3>
<p>The arguments of conditional operations (And, Or) are first converted to boolean if necessary and the result is boolean.</p>
<p>In the case of Or, if the left-hand-side expression evaluates to true, the right-hand-side expression is not evaluated.<br />
</p>
<p>For example:</p>
<pre>
If car<>Null Or GetSpeed()>10 Then...
</pre>

<p>In the above example, if car is not Null, then the right-hand-side of the Or is not evaluated - ie: the GetSpeed function is never called.</p>
<p>In the case of And, if the left-hand-side expression evaluates to false, the right-hand-side expression is not evaluated.<br />
</p>
<p>For example:</p>
<pre>
If enemies.Count > 0 And HasEnemyInSight() Then ...
</pre>

<p>In the above example, if enemies.Count is &lt;= 0, then the right-hand-side of the And is not evaluated - ie: the hasEnemyInSight function is never called.</p>
<h3>Bitwise operators</h3>
<p>When performing bitwise (Shl Shr &amp; | ~) operations, arguments are first implicitly converted to integers if necessary before the operation is performed. The result is also an integer.</p>
<h3>Implicit conversions</h3>
<p>Implicit conversions are automatic conversions performed when assigning a value to a variable, passing parameters to a function, returning a value from a function or when balancing operator operands.</p>
<p>Monkey supports the following implicit conversions:</p>
<table class="c">
<tr><th>Source type</th><th>Target type</th><th>Notes</th></tr>
<tr><td>Boolean</td><td>Integer</td><td>Return 1 if boolean value is true, 0 if false.</td></tr>
<tr><td>Integer</td><td>Floating point</td><td></td></tr>
<tr><td>Integer</td><td>String</td><td></td></tr>
<tr><td>Floating point</td><td>Integer</td><td>Value is converted by discarding fractional part.</td></tr>
<tr><td>Floating point</td><td>String</td><td>Conversion is target dependent.</td></tr>
<tr><td>Derived class object</td><td>Source class object</td><td>Upcast operation.</td></tr>
</table>

<h3>Explicit conversions</h3>
<p>Explicit conversions are conversions from one type to another type which can be performed manually by the programmer .</p>
<p>The syntax for performing an explicit conversion is: <em>TargetType</em> <code>(</code> <em>Expression</em> <code>)</code></p>
<p>For example:</p>
<pre>
Local energyFloat:Float = 120.1000002001

Local energyInt:Int = Int(energyFloat)         'Is 120 now
</pre>

<p>You can perform the following explicit conversions in Monkey:</p>
<table class="c">
<tr><th>Source type</th><th>Target type</th><th>Notes</th></tr>
<tr><td>Integer</td><td>Boolean</td><td>Result is true if source<>0, else false.</td></tr>
<tr><td>Floating point</td><td>Boolean</td><td>Result is true if source<>0.0, else false.</td></tr>
<tr><td>Array</td><td>Boolean</td><td>Result is true if source.Length<>0, else false.</td></tr>
<tr><td>Object</td><td>Boolean</td><td>Result is true if source<>Null, else false.</td></tr>
<tr><td>String</td><td>Boolean</td><td>Result is true if source<>"", else false.</td></tr>
<tr><td>String</td><td>Integer</td><td>Conversion is target dependant.</td></tr>
<tr><td>String</td><td>Floating point</td><td>Conversion is target dependant.</td></tr>
<tr><td>Base class object</td><td>Derived class object</td><td>Result is null if source is not a superclass of derived class.</td></tr>
</table>

<p>In some circumstances, Monkey will automatically perform an explicit conversion of a non-bool value to bool for you. This will occur when evaluating an expression for use with the If and While statements; the Until part of a Repeat loop; and when evaluating the arguments for the Not, Or and And operators. This allows you to use 'shortcut' code such as: If x Then y without the need to compare x with 0, "", [] or null.</p>
<h3>Boxing and unboxing conversions</h3>
<p>A 'box' object is an object designed to contain a single primitive int, float or string value. The process of placing a value into a box object is known as 'boxing', while extracting a value from an object is known as 'unboxing'. To help with writing box objects, Monkey provides some simple features for boxing and unboxing values:</p>
<ul>
<li>
<p>An int, float or string value will be automatically converted to a new box object if that object provides a suitable New( Int ), New( Float ) or New( String ) constructor.</p>
</li>
<li>
<p>An object will be automatically converted to an int, float or string value if that object provides a suitable To:Int(), ToFloat:Float() or ToString:String() method.</p>
</li>
</ul>
<p>For example, here is a simple box class designed to hold an integer value:</p>
<pre>
Class IntBox
    Field value:Int

Method New( value:Int )
        Self.value=value
    End

Method ToInt:Int()
        Return value
    End
End

Function Main()
    Local box:IntBox
    box=10

Local t:Int=box
    Print t
End
</pre>

<a name="statements">

<h2>Statements</h2>
</a>

<p>Program statements may only appear within method or function declarations.</p>
<p>A ; character may optionally appear after any statement, and multiple statements may be placed on the same source code line if separated by the ; character.</p>
<h3>If statement</h3>
<p>The If statement allows you to conditionally execute a block of statements depending on the result of a series of boolean expressions.</p>
<p>The first boolean expression that evaluates to true will cause the associated block of statements to be executed. No further boolean expressions will be evaluated.</p>
<p>If no boolean expression evaluates to true, then the final else block will be executed if present.</p>
<p>The syntax for the If statement is:</p>
<p><code>If</code> <em>Expression</em> [ <code>Then</code> ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>ElseIf</code> <em>Expression</em> [ <code>Then</code> ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Else</code><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>EndIf</code></p>
<p>There may be any number of ElseIf blocks, or none. The final Else block is optional.</p>
<p><code>End</code> or <code>End If</code> may be used instead of <code>EndIf</code>, and <code>Else If</code> may be used instead of <code>ElseIf</code>.</p>
<p>In addtion, a simple one line version of If is also supported:</p>
<p><code>If</code> <em>Expression</em> [ <code>Then</code> ] <em>Statement</em> [ <code>Else</code> <em>statement</em> ]</p>
<h3>The Select statement</h3>
<p>The Select statement allows you to execute a block of statements depending on a series of comparisons.</p>
<p>The first comparison to produce a match will cause the associated block of statements to be executed.</p>
<p>If no comparisons produce a match, then the final default block will be executed if present.</p>
<p>The syntax for the Select statement is:</p>
<p><code>Select</code> <em>Expression</em><br />
<code>Case</code> <em>Expression</em> [ <code>,</code> <em>Expression</em>... ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Default</code><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>End</code> [ <code>Select</code> ]</p>
<p>There may be any number of Case blocks, or none. The final Default block is optional. If the default block is present, it must appear after all Case blocks.</p>
<h3>While loop</h3>
<p>The While loop allows you to execute a block of statements repeatedly while a boolean expression evaluates to true.</p>
<p>Note that a While loop may never actually execute any of it's statements if the expression evaluates to false when the loop is entered.</p>
<p>The syntax for the While loop is:</p>
<p><code>While</code> <em>Expression</em><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Wend</code></p>
<p><code>End</code> or <code>End While</code> may be used instead of <code>Wend</code>.</p>
<p>Exit and Continue may be used within a While loop to abruptly terminate or continue loop execution.</p>
<h3>Repeat loop</h3>
<p>Like the While loop, the Repeat loop also allows you to execute a block of statement repeatedly while a boolean expression evaluates to true.</p>
<p>However, unlike a While loop, a Repeat loop is guaranteed to execute at least once, as the boolean expression is not evaluated until the end of the loop.</p>
<p>The syntax for Repeat/Until loops is:</p>
<p><code>Repeat</code><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Until</code> <em>Expression</em></p>
<p>Or...</p>
<p><code>Repeat</code><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Forever</code></p>
<p>Exit and Continue may be used within a While loop to abruptly terminate or continue loop execution.</p>
<h3>Numeric For loop</h3>
<p>A numeric For loop will continue executing until the value of a numeric index variable reaches an exit value.</p>
<p>The index variable is automatically updated every loop iteration by adding a constant step value.</p>
<p>The syntax for a numeric For loop is:</p>
<p><code>For</code> [ <code>Local</code> ] <em>IndexVariable</em> <code>=</code> <em>FirstValue</em> <code>To</code> | <code>Until</code> <em>LastValue</em> [ <code>Step</code> <em>StepValue</em> ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Next</code></p>
<p><code>End</code> or <code>End For</code> may be used instead of <code>Next</code>.</p>
<p>If present, Local will create a new local index variable that only exists for the duration of the loop. In addition, IndexVariable must include the variable type, or := must be used instead of = to implicitly set the variable's type.</p>
<p>If Local is not present, IndexVariable must be a valid, existing variable.</p>
<p>The use of To or Until determines whether LastValue should be inclusive or exclusive.</p>
<p>If To is used, the loop will exit once the index variable is greater than LastValue (or less than if StepValue is negative).</p>
<p>If Until is used, the loop will exit once the index variable is greater than or equal to LastValue (or less than or equal to if StepValue is negative).</p>
<p>If omitted, StepValue defaults to 1.</p>
<p>Exit and Continue may be used within a numeric For loop to abruptly terminate or continue loop execution.</p>
<h3>For EachIn loop</h3>
<p>A For EachIn loop allows you to iterate through the elements of a collection.</p>
<p>A collection is either an array, a string, or a specially designed object.</p>
<p>The syntax for a For EachIn loop is:</p>
<p><code>For</code> [ <code>Local</code> ] <em>IndexVariable</em> <code>=</code> <code>EachIn</code> <em>Collection</em><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>Next</code></p>
<p><code>End</code> or <code>End For</code> may be used instead of <code>Next</code>.</p>
<p>If present, <code>Local</code> will create a new local index variable that only exists for the duration of the loop. In addition, IndexVariable must include the variable type, or := must be used instead of = to implicitly set the variable's type.</p>
<p>If Local is not present, IndexVariable must be a valid, existing variable.</p>
<p>If Collection is an array, the loop will iterate through each element of the array, and the type of the index variable must match the element type of the array.</p>
<p>If Collection is a string, the loop will iterate through each each character code of the string, and the type of the index variable must be numeric.</p>
<p>If Collection is an object, it must provide the following method:</p>
<pre>
Method ObjectEnumerator:Object()
</pre>

<p>The object returned by this method must itself provide the following methods:</p>
<pre>
Method HasNext:Bool()
Method NextObject:Object()
</pre>

<p>This allows you to build 'collection' style objects, such as the List and Map classes included in the standard Monkey modules that can be iterated through using For EachIn loops.</p>
<h3>Exit and Continue</h3>
<p><code>Exit</code> can be used within While, Repeat and For loops to abruptly exit the loop before the loop termination condition has been met.</p>
<p><code>Continue</code> can be used within While, Repeat and For loops to force the loop to abruptly skip to the next loop iteration, skipping over any statements that may be remaining in the current loop iteration.</p>
<h3>Assignment statements</h3>
<p>An assignment statement modifies a variable's value, and has the syntax:</p>
<p><em>VarExpression</em> <em>Operator</em> <em>Expression</em></p>
<p>Where VarExpression is an expression that evaluates to a variable, and Operator is one of the following:</p>
<p><code>=</code><br />
<code>*=</code><br />
<code>/=</code><br />
<code>Shl=</code><br />
<code>Shr=</code><br />
<code>Mod=</code><br />
<code>+=</code><br />
<code>-=</code><br />
<code>&amp;=</code><br />
<code>~=</code><br />
<code>|=</code><br />
</p>
<p>The <code>=</code> operator is used for plain assignment, while the remaining operators are used for update assignments.</p>
<h3>Expression statements</h3>
<p>You may also use certain expressions as program statements. These are:</p>
<ul>
<li>
<p>Function or method call expressions.</p>
</li>
<li>
<p>New expressions.</p>
</li>
</ul>
<a name="functions">

<h2>Functions</h2>
</a>

<p>A function is a self contained block of statements that can be called (or invoked) repeatedly from elsewhere in the program. Functions can also be passed parameters and return a result.</p>
<p>The syntax for declaring a function is:</p>
<p><code>Function</code> <em>Identifier</em> <code>:</code> <em>ReturnType</em> <code>(</code> <em>Parameters</em> <code>)</code><br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>End</code> [ <code>Function</code> ]</p>
<p>For example:</p>
<pre>
Function Eat:Void( amount:Int )
    ...
End
</pre>

<p>Parameters is a comma separated sequence of function parameters:</p>
<p><em>Identifier</em> <code>:</code> <em>Type</em> [ <code>=</code> <em>InitExpression</em> ]</p>
<p>Or...</p>
<p><em>Identifier</em> <code>:=</code> <em>InitExpression</em></p>
<p>If you provide an InitExpression when declaring a function parameter, this means that the parameter has a default value and that the parameter can be optionally omitted when the function is called.</p>
<p>Once you have declared a function, it can be called with the syntax: </p>
<p><code>FunctionIdentifier</code> <code>(</code> <em>Arguments</em> <code>)</code> </p>
<p>where Arguments is a comma separated sequence of expressions.</p>
<p>For example:</p>
<pre>
Function Sum:Int( x:Int,y:Int )
    Return x+y
End

Function Main()
    Print Sum( 10,20 )
End
</pre>

<p>Here is an example of using default parameters:</p>
<pre>
Function Sum( x:Int=0,y:Int=0,z:Int=0 )
    Print x+y+z
End

Function Main()
    Print Sum()         'same as calling Sum( 0,0,0 )
    Print Sum( 10,20 )  'same as calling Sum( 10,20,0 )
    Print Sum( 10,,30 ) 'same as calling Sum( 10,0,30 )
End
</pre>

<h3>Function overloading</h3>
<p>Functions can also be overloaded. This means that multiple declarations can share the same name, as long as they each have different parameters. Methods can be overloaded in exactly the same way as functions.</p>
<p>When a function is called, Monkey looks at the number and type of the parameters used in the call and looks for a matching overloaded version to use. For example:</p>
<pre>
Function Add( value:Int )
End

Function Add( value:Float )
End

Function Add( value:String )
End

Function Main()
    Add( 10 )   'calls first version as 10 is of type Int
    Add( 10.0 ) 'calls second version as 10.0 is of type Float
    Add( "10" ) 'calls third version as "10" is of type String
End
</pre>

<p>The number of parameters can also be used to differentiate between overloaded functions. For example:</p>
<pre>
Function Set( x )
End

Function Set( x, y )
End

Function Main()
    Set( 10 )    'calls first version
    Set( 10,20 ) 'calls second version as it has two parameters
End
</pre>

<p>When determining which overloaded version to actually use, Monkey uses the following logic:</p>
<ul>
<li>
<p>If an overloaded version is found that is an exact match for the number and type of function call parameters, that version is used. Note that if the function call involves the use of any default parameters, it is not considered an exact match.</p>
</li>
<li>
<p>Otherwise, if there is exactly one overloaded version that can be called by implicitly converting  the function call parameters, that version is used.</p>
</li>
<li>
<p>Otherwise, an error is generated. In this case, you will need to manually cast some or all of the function call parameters to create an exact match.</p>
</li>
</ul>
<p>For example:</p>
<pre>
Function Add( value:Int )
End

Function Add( value:String )
End

Function Main()
    Add( 10 )   'OK, calls first version
    Add( "10" ) 'OK, calls second version
    Add( 10.0 ) 'error - unable to determine which version to call
End
</pre>

<p>The error is caused by the fact that the function call parameter  - '10.0' - is a floating point value and can therefore be implicitly converted to either an integer or a string, so Monkey cannot decide which overload to use.</p>
<p>To solve this problem, you would need to explicitly cast the parameter to either an integer or a string to give Monkey a 'hint' about which version you want used.&nbsp; For example:</p>
<pre>
    Add( Int(10.0) )        'Casts the float to an integer, calls first version
</pre>

<a name="methods">

<h2>Methods</h2>
</a>

<p>A Method is a function that is bound to a class. A method has implicit access to all members of its class, such as fields, globals and other methods and functions..</p>
<p>The syntax for declaring a method is similar to that for declaring a function:</p>
<p><code>Method</code> <em>Identifier</em> <code>:</code> <em>ReturnType</em> <code>(</code> <em>Parameters</em> <code>)</code> [ <code>Property</code> ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Statements...</em><br />
<code>End</code> [ <code>Method</code> ]</p>
<p>Within a method you can also use the special <code>Self</code> and <code>Super</code> variables:</p>
<ul>
<li>
<p><code>Self</code> may be used within a method to access the object the method is associated with.</p>
</li>
<li>
<p><code>Super</code> may be used within a method to call 'super class' methods.</p>
</li>
</ul>
<p>The optional <code>Property</code> keyword can be used to declare a 'property method'.</p>
<p>A property method with 0 parameters can be invoked without any brackets. A property method with 1 parameter can be invoked be using it as the left-hand-side of an assignment statement, in which case the right-hand-side expression of the assignment is passed to the property method.</p>
<p>You can therefore create methods that behave like fields, but actually execute code when they are read or written. You can use method overloading to provide both read and write property methods, or provide just a read method, or even just a write method.</p>
<p>It is illegal to declare a property method with 2 or more parameters.</p>
<a name="classes">

<h2>Classes</h2>
</a>

<p>A class is a kind of 'blueprint' for creating objects at runtime.</p>
<p>The syntax for declaring a class is:</p>
<p><code>Class</code> Identifier [ &lt; Parameters &gt; ] [ <code>Extends</code> Class ] [ <code>Implements</code> Interfaces ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Declarations...</em><br />
<code>End</code> [ <code>Class</code> ]</p>
<p>Classes can contain field, method, constant, global and function declarations.</p>
<p>If no base class is specified using Extends, the class defaults to extending the built in Object class.</p>
<p>The Implements keyword is used to implement interfaces, and must be followed by a comma separated list of interface names. Please refer to the Interfaces section for more on interfaces. </p>
<p>A class is also a valid scope, and any constants, globals and functions declared within a class can be accessed outside of the class using the scope member access operator '.'. For example:</p>
<pre>
Class C
   Global T
End

Function Main()
    C.T=10
End
</pre>

<p>Once you have declared a class, you can create objects of that class at runtime using the New operator. For example:</p>
<pre>
Class MyClass
    Field x,y,z
End

Function Main()
    Local myObject:=New MyClass
    myObject.x=10
    myObject.y=20
    myObject.z=30
End
</pre>

<h3>Constructors</h3>
<p>Constructors are special methods that are called each time an object is created with New.</p>
<p>To declare a constructor, you simply declare a class method and name it New.</p>
<p>Constructors can take parameters and can be overloaded.</p>
<p>To invoke a super class constructor within a constructor, use the special <code>Super</code> variable.</p>
<a name="interfaces">

<h2>Interfaces</h2>
</a>

<p>An interface is similar to a class, except that it can only contain constants and abstract methods.</p>
<p>Classes can implement an interface using the Implements keyword in the class declaration.</p>
<p>Classes that implement an interface must declare each method declared in the interface.</p>
<p>An interface can be used where ever a class is expected, for example when declaring the types of variables, or function return types. An interface cannot however be used with New.</p>
<p>An Interface can also optionally extend existing interfaces, in which cases all methods in all extended interfaces must be declared by any implementing classes.</p>
<p>Interfaces can not be generic.</p>
<p>The syntax for declaring an interface is:</p>
<p><code>Interface</code> <em>Identifier</em> [ <code>Extends</code> <em>Interfaces</em> ]<br />
&nbsp;&nbsp;&nbsp;&nbsp; <em>Declarations...</em><br />
<code>End</code> [ <code>Interface</code> ]</p>
<p>All methods declared inside an interface are automatically treated as abstract, and can therefore have no 'body'.</p>
<p>Here is an example of using interfaces:</p>
<pre>
Interface Moveable
    Method Move()
End

Interface Drawable
    Method Draw()
End

Class Actor Implements Moveable,Drawable
    Method Move()
        Print "Actor.Move()"
    End
    Method Draw()
        Print "Actor.Draw()"
    End
End

Function Move( moveable:Moveable )
    moveable.Move
End

Function Draw( drawable:Drawable )
    drawable.Draw
End

Function Main()
    Local actor:=New Actor

Move actor
    Draw actor
End
</pre>

<a name="generics">

<h2>Generic classes</h2>
</a>

<p>Generic classes allow you to write code that is not specific to a single data type.</p>
<p>A generic class is declared in a similar way to a normal class, only with an additional set of 'type parameters' enclosed within <code>&lt;</code> and <code>&gt;</code>.</p>
<p>For example:</p>
<pre>
Class Pointer<T>
    Method Set( data:T )
        _data=data
    End

Method Get:T()
        Return _data
    End

Private

Field _data:T

End
</pre>

<p>Type parameters can be any valid identifier. Here, T is such a type parameter.</p>
<p>Within the declaration of a generic class, type parameters may be used anywhere a type is normally expected, for example, when declaring variables and function return types, and when creating new objects or arrays.</p>
<p>When it comes to actually using a generic class, you must provide actual types to be used in place of type parameters. Types parameters can be of any valid type, including int, float, string and array.</p>
<p>For example:</p>
<pre>
Class Actor
End

Function Main()
    Local pointer:Pointer<Actor>
    pointer=New Pointer<Actor>
    pointer.Set New Actor
    Local actor:=pointer.Get()
End
</pre>

<p>The syntax Pointer<Actor> indicates an 'instantiation' of the generic class Pointer<T>.</p>
<p>This is in itself a unique class, so each time you use the Pointer<T> class with a different type  for T, you are actually creating a whole new class.</p>
<p>Generic classes are commonly used for writing container classes such as lists, stacks and so on, and the standard Monkey modules provide a set of simple generic container classes.</p>
<a name="modules">

<h2>Modules</h2>
</a>

<p>A Monkey module corresponds to a single Monkey source file, and provides a named scope for the constants, globals, functions and classes declared in that file. Every Monkey source file declares a module, and every module has an associated source file.</p>
<p>The name of the module scope is the same as the name of the file (minus the directory path and file extension), so the names of Monkey source files must also be valid Monkey identifiers.</p>
<p>It is also strongly recommend that file/module names be completely lowercase - both to prevent any issues with cased/uncased filesystems and to provide consistency with the standard module set.</p>
<p>One module may import another using the import statement. All import statements must appear at the top of a module before any declarations. The syntax for an import statement is:</p>
<p><code>Import</code> <em>ModulePath</em></p>
<p>Where ModulePath describes the file location of the Monkey module to import. This must be a sequence of 'dot' separated identifiers, and is treated as a relative filesystem path with dots representing directory separators. The last component in the path represents either an actual .monkey source file, or a directory containing a .monkey source file of the same name.</p>
<p>Given a module's relative path, Monkey will look for an actual module to import in the following locations (and in this order):</p>
<ul>
<li>
<p>The current directory - ie: the directory the importing file is in.</p>
</li>
<li>
<p>The project directory - ie: the directory the main source file is in. This is the source file that was passed to the 'trans' compiler, and that contains the declaration for Main().</p>
</li>
<li>
<p>The modules directory - ie: the directory named 'modules' in the Monkey distribution.</p>
</li>
</ul>
<p>For example, given the following import directive:</p>
<pre>
Import myutil.mycolor
</pre>

<p>Monkey will first look for the files myutil/mycolor.monkey and myutil/mycolor/mycolor.monkey in the current directory.</p>
<p>(Note: the reason modules are allowed to be represented as either a single .monkey file, or as a .monkey file within a directory of the same name is for pure convenience. Sometimes it's more convenient for a module to consist of a single file, while sometimes it's more convenient for a module to have its own directory.)</p>
<p>If either is found, it is imported into the current module and the search ends.</p>
<p>If both are found, an error is generated.</p>
<p>If neither is found the search continues with the project directory and, failing that, the modules directory.</p>
<p>If the module is not found anywhere, an error is generated.</p>
<p>Once successfully imported, the importing module can access the declarations made in the imported module, by using the imported module's name as a scope.</p>
<p>Here is a simple import example:</p>
<pre>
'----- file1.monkey -----
Import file2                'after this, file2 can be used as a scope

Function Main()
    Print file2.X        'access global X in file2 module

file2.Test                'access function Test in file2 module
End

'---- file2.monkey ----
Global X:=1

Function Test()
    Print "file2.Test"
End
</pre>

<p>When accessing identifiers in imported modules, Monkey allows you to omit the module scope as long as there are no 'clashes' between identifiers in multiple modules. For example:</p>
<pre>
'----- file1.monkey ----
Import file2
Import file3

Function Main()

Print X     'OK, accesses file2.X
    Print Y     'OK, accesses file3.Y
    Test        'ERROR! Which Test? file2.Test or file3.Test?
    file2.Test  'OK, I now know which module to get Test from

End

'----- file2.monkey  -----
Global X:=1

Function Test()
    Print "file2.Test"
End

'----- file3.monkey -----
Global Y:=2

Function Test()
    Print "file3.Test"
End
</pre>

<p>By default, any imports made by a module are automatically made available to importers of that module. That is, if module X imports module Y, and module Y imports module Z, the result is that module X effectively imports module Z.</p>
<p>However, if an import is declared to be private, that import is NOT made available. For example:</p>
<pre>
'----- file1.monkey -----
Import file2
Function Main()

Print X  'OK, accesses file2.X
    Print Y  'OK, accesses file3.Y
    Print Z  'ERROR! can't see file.Z

End

'----- file2.monkey -----
Import file3                'Public import: When you import file2, you also import file3

Private
Import file4                'Private - ie: internal use only. Only file2 can access file4.&nbsp; file1 cannot access file4.

Public
Global X:=1

'----- file3.monkey -----
Global Y:=2

'----- file4.monkey -----
Global Z:=3
</pre>

<p>Modules can be stored in a directory hierarchy and imported using a 'dotted' module path, for example:</p>
<pre>
'----- file1.monkey -----
Import file2
Import util.file3

Function Main()
    Print file2.X
    Print file3.Y
End

'----- util/file2.monkey ----
Global X:=1

'----- util/file3.monkey -----
Global Y:=2
</pre>

<p>Note that the directory path (in this case, 'util') is not used in any way except to locate the module. The module name is still just 'file3' - not 'util.file3'.</p>
<h3>The Alias directive</h3>
<p>The Alias directive allows you to assign a local name to a constant, global, function or class declared in another module. This can be used to create 'shortcuts' for clashing identifiers.</p>
<p>The syntax for Alias is:</p>
<p><code>Alias</code> <em>Identifier</em> <code>=</code> <em>ModulePath</em> <code>.</code> <em>Identifier</em></p>
<p>Alias directives must appear in the 'import' section of a module, before any code.</p>
<p>For example:</p>
<pre>
'----- file1.monkey -----
Import file2
Import file3

Alias T=file2.T                'which 'T' to use

Function Main()
    Print T                   'Prints '1'
End

'----- file2.monkey -----
Global T:=1

'----- file3.monkey -----
Global T:=2
</pre>

<a name="visibility">

<h2>Public and Private</h2>
</a>

<p>The Public and Private directives are used to control the visibility of subsequent declarations in a module or class.</p>
<p>If the Public directive is used in the main body of a module, all subsequent declarations will be public, and will be visible outside of the current module.</p>
<p>If the Private directive is used in the main body of a module, all subsequent declarations will be private and will not be visible outside of the current module.</p>
<p>For example:</p>
<pre>
Private
Global x,y,z        'These are private to the current module

Public
Global P,Q,R        'These can be used by any module
</pre>

<p>When used inside a class declaration, Public and Private work in a similar way to control the visibility of subsequent member declarations. For example:</p>
<pre>
Class MyClass
    Private
    Field x,y,z        'these are NOT visible outside of this module.

Public
    Field P,Q,R        'these ARE visible outside of this module.
End
</pre>

<p>Note that private class members are not private to the class, but to the entire module. This means that code outside of the class but within the same module can still access class private members.</p>
<a name="extern">

<h2>External declarations</h2>
</a>

<p>The Extern directive is used to connect Monkey code to non-Monkey code. It lets you mix Monkey code (to be translated into the target platform language) with native target platform code.</p>
<p>When the Extern directive is used in the main body of a module, all subsequent global, function and class declarations will be treated as external declarations.</p>
<p>External declarations are assumed to be implemented elsewhere in native code, and as such may not contain a 'body'.</p>
<p>In the case of external global variables, this means the global may not be initialized - it is assumed to be initialized by native code.</p>
<p>In the case of external functions, this means the function may not contain any code, and must not be terminated with an End directive.</p>
<p>In the case of external classes, this means any globals or methods declared in the class may not contain a 'body' either.</p>
<p>External declarations may however be assigned a 'symbol' in the form of a string literal. This is the native symbol to be used by the Monkey translator when the declaration is referenced by Monkey code.</p>
<p>By default, external declarations are public. You can use Extern Private to prevent external declarations from being visible outside the current module.</p>
<p>Here are some examples of using extern:</p>
<pre>
Extern

Global ActiveDriver:Driver="xyzActiveDriver"  'Native name of this global is xyzActiveDriver

Class Driver="xyzDriver"   'The native name of this class is 'xyzDriver'.
    Method Method1()       'By default, native name is same as declaration name - Method1 here.
    Method Method2()       'native name is Method2
End

Public        'return to public declarations
</pre>

<a name="memory">

<h2>Memory Management</h2>
</a>

<p>Monkey is a garbage collected language, and depends on the underlying target language to provide memory management.</p>
<p>Finalizers are not supported. If you need an object to be 'destroyable', you will need to add a 'Destroy' type method.</p>
<p>The garbage collector is capable of collecting cyclic data structures such as linked lists automatically.</p>
<p>The current C++ garbage collector will only collect garbage when control is returned to the OS. In the case of C++ Mojo targets such as IOS and GLFW, this occurs after any of the 'On' methods such as OnCreate, OnUpdate etc return.</p>
<p>In general, the best way to use the garbage collector is to ignore it! Although such practices as 'nulling out' object references are common, they are seldom required. </p>
<p>But it's a good idea to monitor your apps memory requirements as you develop anyway. This will allow you to catch any memory issues, GC related or otherwise, early on.</p>
<a name="preprocessor">

<h2>The preprocessor</h2>
</a>

<p>Monkey contains a very simple built-in preprocessor based on the syntax of the Monkey If statement that allows you to enable or disable blocks of code from being generated or translated, based on certain conditions.</p>
<p>The following preprocessor directives are supported:</p>
<p>#If<br />
#ElseIf<br />
#Else<br />
#End<br />
#Rem<br />
#Print<br />
#Error<br />
</p>
<p>Preprocessor directives must appear at the start of a line, and may be preceded by optional whitespace.</p>
<p>The #If and #Else If directives must be followed by a constant Monkey expression. If this expression evaluates to true, then code generation is enabled, otherwise it is disabled.</p>
<p>The following built in constants may be used in preprocessor expressions:</p>
<table class="c">
<tr><th>Constant</th><th>Possible values</th></tr>
<tr><td>HOST</td><td>winnt macos</td></tr>
<tr><td>LANG</td><td>js as cs java cpp</td></tr>
<tr><td>TARGET</td><td>html5 flash xna android ios glfw stdcpp</td></tr>
<tr><td>CONFIG</td><td>debug release</td></tr>
</table>

<p>The #Rem directive is exactly the same as #If False - it unconditionally disables code generation. Note that this allows 'block rems' to be 'nested'.</p>
      
      
    
  
</div>


    </div>
    </body>

<!-- Mirrored from blitz-wiki.appspot.com/Language reference?format=mobile by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 02 Feb 2012 22:34:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
</html>
